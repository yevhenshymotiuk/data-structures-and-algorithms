#+TITLE: [[https://www.programiz.com/dsa/trees][Tree]]

* Table of contents :TOC_2:
- [[#binary-seach-tree][Binary Seach Tree]]
  - [[#implementation][Implementation]]
  - [[#traversals][Traversals]]
- [[#prefix-tree-trie][Prefix Tree (Trie)]]
  - [[#implementation-1][Implementation]]

* [[https://www.programiz.com/dsa/binary-search-tree][Binary Seach Tree]]
** Implementation
#+begin_src python :session :results output
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class BST:
    @classmethod
    def inorder(cls, root):
        """Inorder traversal."""
        if root:
            cls.inorder(root.left)
            print(root.val, end=" ")
            cls.inorder(root.right)

    @classmethod
    def insert(cls, root, val):
        """Insert a node."""
        # return new node if tree is empty
        if not root:
            return TreeNode(val)
        if val < root.val:
            root.left = cls.insert(root.left, val)
        else:
            root.right = cls.insert(root.right, val)
        return root

    @classmethod
    def _inorder_successor(cls, root):
        cur = root
        # find the leftmost leaf
        while cur.left:
            cur = cur.left
        return cur

    @classmethod
    def delete(cls, root, val):
        # return if tree is empty
        if not root:
            return None
        # find the node to be deleted
        if val < root.val:
            root.left = cls.delete(root.left, val)
        elif val > root.val:
            root.right = cls.delete(root.right, val)
        else:
            # if the node has one child or no children
            if not root.left:
                temp = root.right
                root = None
                return temp
            elif not root.right:
                temp = root.left
                root = None
                return temp
            # if the node has two children
            # place the inorder successor in position of the node to be deleted
            suc = cls._inorder_successor(root.right)
            root.val = suc.val
            root.right = cls.delete(root.right, suc.val)
        return root


root = None
values = [3, 1, 5, 0, 2, 4, 6]
for v in values:
    root = BST.insert(root, v)
print("Inorder traversal: ", end=" ")
BST.inorder(root)
print("\nDelete 4")
BST.delete(root, 4)
print("Inorder traversal: ", end=" ")
BST.inorder(root)
#+end_src

#+RESULTS:
: Inorder traversal:  0 1 2 3 4 5 6
: Delete 4
: Inorder traversal:  0 1 2 3 5 6

** [[https://www.programiz.com/dsa/tree-traversal][Traversals]]
*** Preorder
#+begin_example
root, left, right

 __1__
/     \
0     2

1, 0, 2
#+end_example

*** Inorder
#+begin_example
left, root, right

 __1__
/     \
0     2

0, 1, 2
#+end_example

*** Postorder
#+begin_example
left, right, root

 __1__
/     \
0     2

0, 2, 1
#+end_example

*** Level order
#+begin_example
level 0 ([root]) + level 1 + ... + level n - 1

   __3__
  /     \
 _1_   _5_
/   \ /   \
0   2 4   6

3, 1, 5, 0, 2, 4, 6
#+end_example

* [[https://www.freecodecamp.org/news/trie-prefix-tree-algorithm-ee7ab3fe3413/?utm_source=pocket_mylist][Prefix Tree (Trie)]]
** Implementation
#+begin_src python :session :results output
class Trie:
    def __init__(self):
        """
        Initialize the data structure.
        """
        self.root = {}
        self.end = "#"

    def insert(self, word: str) -> None:
        """
        Insert a word into the trie.
        """
        node = self.root
        for c in word:
            node = node.setdefault(c, {})
        node[self.end] = self.end

    def search(self, word: str) -> bool:
        """
        Return if the word is in the trie.
        """
        node = self.root
        for c in word:
            if c not in node:
                return False
            node = node[c]
        return self.end in node

    def startsWith(self, prefix: str) -> bool:
        """
        Return if there is any word in the trie that starts with the given prefix.
        """
        node = self.root
        for c in prefix:
            if c not in node:
                return False
            node = node[c]
        return True

    def all_words(self):
        """
        Return all the words in the trie.
        """
        node = self.root
        ans = []
        self._collect(node, "", ans)
        return ans

    def _collect(self, node, path, ans):
        for k in node:
            if k == self.end:
                ans.append(path)
                continue
            self._collect(node[k], path + k, ans)

    def words_with_prefix(self, prefix: str):
        """
        Return all possible words with common prefix.
        """
        node = self.root
        for c in prefix:
            if c not in node:
                return []
            node = node[c]
        ans = []
        self._words_with_prefix_helper(node, prefix, ans)
        return ans

    def _words_with_prefix_helper(self, node, prefix, ans):
        for k in node:
            if k == self.end:
                ans.append(prefix)
                continue
            self._words_with_prefix_helper(node[k], prefix + k, ans)

    def longest_prefix(self, s):
        """
        Return longest prefix of s in the trie.
        """
        ans = ""
        if not s:
            return ans
        node = self.root
        for c in s:
            if c not in node:
                return ans
            node = node[c]
            ans += c
        return ans


trie = Trie()
words = [
    "bag",
    "baggage",
    "bags",
    "backpack",
    "badminton",
]
for w in words:
    trie.insert(w)
print(trie.words_with_prefix("bag"))
#+end_src

#+RESULTS:
: ['bag', 'baggage', 'bags']
