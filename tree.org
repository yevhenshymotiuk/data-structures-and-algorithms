#+TITLE: [[https://www.programiz.com/dsa/trees][Tree]]

* Table of contents :TOC_2:
- [[#binary-seach-tree][Binary Seach Tree]]
  - [[#traversals][Traversals]]
  - [[#implementation][Implementation]]
  - [[#complexities][Complexities]]
- [[#prefix-tree-trie][Prefix Tree (Trie)]]
  - [[#implementation-1][Implementation]]
  - [[#complexities-1][Complexities]]

* [[https://www.programiz.com/dsa/binary-search-tree][Binary Seach Tree]]
** [[https://www.programiz.com/dsa/tree-traversal][Traversals]]
*** Preorder
#+begin_example
root, left, right

 __1__
/     \
0     2

1, 0, 2
#+end_example

*** Inorder
#+begin_example
left, root, right

 __1__
/     \
0     2

0, 1, 2
#+end_example

*** Postorder
#+begin_example
left, right, root

 __1__
/     \
0     2

0, 2, 1
#+end_example

*** Level order
#+begin_example
level 0 ([root]) + level 1 + ... + level n - 1

   __3__
  /     \
 _1_   _5_
/   \ /   \
0   2 4   6

3, 1, 5, 0, 2, 4, 6
#+end_example

** Implementation
#+begin_src python :session :results output
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class BST:
    @classmethod
    def inorder(cls, root):
        """Inorder traversal."""
        if root:
            cls.inorder(root.left)
            print(root.val, end=" ")
            cls.inorder(root.right)

    @classmethod
    def insert(cls, root, val):
        """Insert a node."""
        # return new node if tree is empty
        if not root:
            return TreeNode(val)
        if val < root.val:
            root.left = cls.insert(root.left, val)
        else:
            root.right = cls.insert(root.right, val)
        return root

    @staticmethod
    def _inorder_successor(root):
        """Find inorder successor."""
        cur = root
        # find the leftmost leaf
        while cur.left:
            cur = cur.left
        return cur

    @classmethod
    def delete(cls, root, val):
        """Delete a node."""
        # return if tree is empty
        if not root:
            return None
        # find the node to be deleted
        if val < root.val:
            root.left = cls.delete(root.left, val)
        elif val > root.val:
            root.right = cls.delete(root.right, val)
        else:
            # if the node has one child or no children
            if not root.left or not root.right:
                temp = root.right if not root.left else root.left
                root = None
                return temp
            # if the node has two children
            # place the inorder successor in position of the node to be deleted
            suc = cls._inorder_successor(root.right)
            root.val = suc.val
            root.right = cls.delete(root.right, suc.val)
        return root


root = None
values = [3, 1, 5, 0, 2, 4, 6]
for v in values:
    root = BST.insert(root, v)
print("Inorder traversal: ", end=" ")
BST.inorder(root)
print("\nDelete 4")
BST.delete(root, 4)
print("Inorder traversal: ", end=" ")
BST.inorder(root)
#+end_src

#+RESULTS:
: Inorder traversal:  0 1 2 3 4 5 6
: Delete 4
: Inorder traversal:  0 1 2 3 5 6

** Complexities
*** Time
| Operation | Average Case | Worst Case |
|-----------+--------------+------------|
| Search    | O(log n)     | O(n)       |
| Insertion | O(log n)     | O(n)       |
| Deletion  | O(log n)     | O(n)       |
Where ~n~ is the number of nodes in the tree

*** Space
The space complexity for all the operations is ~O(n)~, where ~n~ is number of nodes

* [[https://www.freecodecamp.org/news/trie-prefix-tree-algorithm-ee7ab3fe3413/?utm_source=pocket_mylist][Prefix Tree (Trie)]]
** Implementation
#+begin_src python :session :results output
from __future__ import annotations
from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.is_word = False

    def insert(self, word: str) -> None:
        """Insert a word."""
        t = self
        for c in word:
            t = t.children[c]
        t.is_word = True

    def _delete_helper(self, t: Trie, word: str, i: int) -> bool:
        c = word[i]
        if not c in t.children:
            return False
        ct = t.children[c]
        # last char and end of a word
        if i == len(word) - 1 and ct.is_word:
            t.children.pop(c)
            return not ct.children
        if self._delete_helper(ct, word, i + 1) and not ct.children:
            t.children.pop(c)
            return True
        return False

    def delete(self, word: str) -> None:
        """Delete a word."""
        self._delete_helper(self, word, 0)

    def search(self, word: str) -> bool:
        """Search for a word."""
        t = self
        for c in word:
            if c not in t.children:
                return False
            t = t.children[c]
        return t.is_word

    def starts_with(self, prefix: str) -> bool:
        """Search for a prefix."""
        t = self
        for c in prefix:
            if c not in t.children:
                return False
            t = t.children[c]
        return True


trie = Trie()
words = [
    "bag",
    "baggage",
    "bags",
    "backpack",
    "badminton",
]
for w in words:
    trie.insert(w)
print(f"Word 'bags' exists: {trie.search('bags')}")
print(f"Prefix 'back' exists: {trie.starts_with('back')}")
trie.delete("backpack")
print(f"Prefix 'back' exists: {trie.starts_with('back')}")
#+end_src

#+RESULTS:
: Word 'bags' exists: True
: Prefix 'back' exists: True
: Prefix 'back' exists: False

** Complexities
*** Time
| Operation   | Average Case | Worst Case |
|-------------+--------------+------------|
| Search      | O(s)         | O(s)       |
| Insertion   | O(s)         | O(s)       |
| Starts With | O(p)         | O(p)       |
Where ~s~ is the length of the string and ~p~ is the length of the prefix

*** Space
The space complexity for all the operations is ~O(n)~, where ~n~ is number of nodes
